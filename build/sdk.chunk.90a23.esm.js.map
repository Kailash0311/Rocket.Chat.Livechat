{"version":3,"sources":["webpack:///../../../src/lib/clients/Livechat.ts","webpack:///../../../src/lib/drivers/index.ts","webpack:///../../../src/lib/api/api.ts","webpack:///../../src/lib/log.ts","webpack:///../../src/lib/util.ts","webpack:///../../../src/lib/drivers/ddp.ts","webpack:///../../src/lib/message.ts","webpack:///../../../src/lib/api/Livechat.ts","webpack:///../../src/interfaces/index.ts"],"names":["logger","allPublic","rooms","integrationId","protocol","config","livechatStream","userId","socket","Promise","resolve","import","Protocols","DDP","this","then","DDPDriver","Error","Object","keys","join","connect","options","callback","disconnect","unsubscribe","subscription","unsubscribeAll","subscribeNotifyAll","subscribeLoggedNotify","subscribeNotifyUser","onMessage","cb","onTyping","onAgentChange","rid","subscribe","onStreamData","args","type","data","onAgentStatusChange","status","onQueuePositionChange","notifyVisitorTyping","username","typing","credentials","token","topic","eventName","visitorToken","subscribeRoom","event","setUpConnection","methodCall","host","_headers","obj","getHeaders","customHeaders","headers","getBody","FormData","JSON","stringify","get","url","fetch","encodeURI","getParams","method","handle","post","body","put","delete","r","json","map","k","encodeURIComponent","regExpSuccess","client","currentLogin","request","endpoint","auth","ignore","debug","loggedIn","result","success","hasDataInsideResult","error","del","Client","every","e","test","login","me","authToken","logout","prepareMessage","content","Message","roomId","EventEmitter","info","warning","warn","replaceLog","externalLog","InternalLog","func","waitMilliseconds","immediate","timeout","self","doLater","undefined","apply","callNow","clearTimeout","setTimeout","ssl","replace","prototype","removeAllListeners","_listeners","resume","sent","lastPing","Date","now","subscriptions","handlers","open","ms","reopen","reject","close","reopenInterval","clearInterval","setInterval","alive","connection","onerror","err","onmessage","bind","onclose","onClose","onopen","onOpen","send","msg","version","support","connected","session","ping","catch","emit","code","openTimeout","pingTimeout","reason","parse","message","collection","once","id","stringdata","listener","off","call","params","response","loginParams","subscribeAll","isLoginPass","isLoginOAuth","isLoginAuthenticated","isLoginResult","user","password","digest","sha256","algorithm","onEvent","on","name","subs","key","all","unsubAll","useSsl","hostToWS","readyState","Socket","joinedIds","c","ddp","cancelled","rejectionTimeout","eventname","stop","ejsonMessage","isTyping","ts","$date","moreConfigs","others","bot","i","guest","grantVisitor","room","closeChat","transferChat","department","chatSurvey","survey","visitor","deleteVisitor","updateVisitorStatus","nextAgent","agent","sendMessage","editMessage","deleteMessage","loadMessages","messages","sendOfflineMessage","sendVisitorNavigation","page","requestTranscript","email","videoCall","sendCustomField","field","sendCustomFields","fields","uploadFile","formData","headersNeededForUpload","append","file","oath","credentialToken","credentialSecret"],"mappings":"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","file":"sdk.chunk.90a23.esm.js","sourcesContent":["/**\n\t* @module LivechatDriver\n\t* Provides high-level helpers for Livechat connection, method calls, subscriptions.\n\t*/\nimport LivechatRest from '../api/Livechat'\nimport { ISocket, Protocols, IDriver } from '../drivers'\nimport { logger as Logger } from '../log'\nimport {\n\tILogger,\n\tISocketOptions,\n\tICallback,\n\tISubscription\n} from '../../interfaces'\n\nexport default class LivechatClient extends LivechatRest implements ISocket {\n  livechatStream: string = 'stream-livechat-room'\n  userId: string = ''\n  logger: ILogger = Logger\n  socket: Promise<ISocket | IDriver> = Promise.resolve() as any\n  constructor ({ logger, allPublic, rooms, integrationId, protocol = Protocols.DDP, ...config }: any) {\n    super({ logger, ...config })\n    this.import(protocol, config)\n  }\n  import (protocol: Protocols, config: any) {\n    switch (protocol) {\n      // case Protocols.MQTT:\n      //   this.socket = import(/* webpackChunkName: 'mqtttest' */ '../drivers/mqtt').then(({ MQTTDriver }) => new MQTTDriver({ logger: this.logger, ...config }))\n      //   break\n      case Protocols.DDP:\n        this.socket = import(/* webpackChunkName: 'ddptest' */ '../drivers/ddp').then(({ DDPDriver }) => new DDPDriver({ logger: this.logger, ...config }))\n        break\n      default:\n        throw new Error(`Invalid Protocol: ${protocol}, valids: ${Object.keys(Protocols).join()}`)\n    }\n  }\n  async connect (options: ISocketOptions, callback?: ICallback): Promise <any> {\n    return (await this.socket as ISocket).connect(options).then(() => (this.setUpConnection()))\n  }\n  async disconnect (): Promise<any> { return (await this.socket as ISocket).disconnect() }\n  async unsubscribe (subscription: ISubscription): Promise<any> { return (await this.socket as ISocket).unsubscribe(subscription) }\n  async unsubscribeAll (): Promise<any> { return (await this.socket as ISocket).unsubscribeAll() }\n  async subscribeNotifyAll (): Promise<any> { return (await this.socket as IDriver) .subscribeNotifyAll() }\n  async subscribeLoggedNotify (): Promise<any> { return (await this.socket as IDriver) .subscribeLoggedNotify() }\n  async subscribeNotifyUser (): Promise<any> { return (await this.socket as IDriver) .subscribeNotifyUser() }\n  async onMessage (cb: ICallback): Promise<any> { return (await this.socket as IDriver).onMessage(cb) }\n  async onTyping (cb: ICallback): Promise<any> { return (await this.socket as IDriver).onTyping(cb) }\n  async onAgentChange (rid: string, cb: ICallback) {\n    await this.subscribe(this.livechatStream, rid)\n    await this.onStreamData(this.livechatStream, ({ fields: { args: [{ type, data }] } }: any) => {\n      if (type === 'agentData') {\n        cb(data)\n      }\n    })\n  }\n  async onAgentStatusChange (rid: string, cb: ICallback) {\n    await this.subscribe(this.livechatStream, rid)\n    await this.onStreamData(this.livechatStream, ({ fields: { args: [{ type, status }] } }: any) => {\n      if (type === 'agentStatus') {\n        cb(status)\n      }\n    })\n  }\n\n  async onQueuePositionChange (rid: string, cb: ICallback) {\n    await this.subscribe(this.livechatStream, rid)\n    await this.onStreamData(this.livechatStream, ({ fields: { args: [{ type, data }] } }: any) => {\n      if (type === 'queueData') {\n        cb(data)\n      }\n    })\n  }\n\n  async notifyVisitorTyping (rid: string, username: string, typing: boolean) {\n    return (await this.socket as IDriver).notifyVisitorTyping(rid, username, typing, this.credentials.token)\n  }\n\n  async subscribe (topic: string, eventName: string) {\n    const { token } = this.credentials\n    return (await this.socket as ISocket).subscribe(topic, eventName, { token, visitorToken: token })\n  }\n\n  async subscribeRoom (rid: string) {\n    const { token } = this.credentials\n    return (await this.socket as IDriver).subscribeRoom(rid, { token, visitorToken: token })\n  }\n\n  async onStreamData (event: string, cb: ICallback): Promise<any> {\n    return (await this.socket as ISocket).onStreamData(event, cb)\n  }\n\n  async setUpConnection () {\n    const { token } = this.credentials\n    return (await this.socket as IDriver).methodCall('livechat:setUpConnection', { token })\n  }\n}\n","/**\n * @module Socket\n * Provides high-level helpers for DDP connection, method calls, subscriptions.\n */\n\nimport { EventEmitter } from 'tiny-events'\nimport {\n  ILogger,\n  ISocketOptions,\n  ICallback,\n  ISubscription,\n  ICredentials\n} from '../../interfaces'\n\nexport interface ISocket {\n  logger: ILogger\n  connect (options: ISocketOptions): Promise<ISocket | IDriver>\n  disconnect (): Promise<ISocket>\n  subscribe (topic: string, ...args: any[]): Promise<ISubscription>\n  unsubscribe (subscription: ISubscription): Promise<ISocket>\n  unsubscribeAll (): Promise<ISocket>\n\n  onStreamData (event: string, cb: ICallback): Promise<any>\n\n  on (event: string, listener: Function): EventEmitter\n  once (event: string, listener: Function): EventEmitter\n  off (event?: string, listener?: Function): EventEmitter\n  emit (event: string, ...args: any[]): boolean\n  listeners (event: string): Function[]\n  removeAllListeners (event?: string): Function[]\n  hasListeners (event: string): boolean\n}\n\nexport interface IDriver {\n  config: any\n  login (credentials: ICredentials, args: any): Promise<any>\n\n  subscribeRoom (rid: string, ...args: any[]): Promise<ISubscription[]>\n\n  onMessage (cb: ICallback): void\n\n  subscribeNotifyAll (): Promise<any>\n\n  subscribeLoggedNotify (): Promise<any>\n\n  subscribeNotifyUser (): Promise<any>\n\n  subscribeNotifyUser (): Promise<IDriver>\n\n  onTyping (cb: ICallback): Promise<any>\n\n  notifyVisitorTyping (rid: string, username: string, typing: boolean, token: string): Promise<any>\n\n  methodCall (method: string, ...args: any[]): Promise<any>\n}\n\nexport enum Protocols {\n\tMQTT = 'mqtt',\n\tDDP = 'ddp'\n}\n","import { logger as Logger } from '../log'\n\nimport {\n\tILogger,\n\tILoginResultAPI,\n\tIAPIRequest,\n\tIMessage,\n\tICredentials\n} from '../../interfaces'\n\nimport { Message } from '../message'\n\nimport { EventEmitter } from 'tiny-events'\n\n/** Check for existing login */\n// export function loggedIn () {\n//   return (currentLogin !== null)\n// }\n\n/**\n\t* Prepend protocol (or put back if removed from env settings for driver)\n\t* Hard code endpoint prefix, because all syntax depends on this version\n\t*/\n// export const url = `${(host.indexOf('http') === -1) ? host.replace(/^(\\/\\/)?/, 'http://') : host}/api/v1/`\n\n/** Populate auth headers (from response data on login) */\n// export function setAuth (authData: {authToken: string, userId: string}) {\n//   client.defaults.headers.common['X-Auth-Token'] = authData.authToken\n//   client.defaults.headers.common['X-User-Id'] = authData.userId\n// }\n\n// /** Clear headers so they can't be used without logging in again */\n// export function clearHeaders () {\n//   delete client.defaults.headers.common['X-Auth-Token']\n//   delete client.defaults.headers.common['X-User-Id']\n// }\n\n// /**\n// \t* Login a user for further API calls\n// \t* Result should come back with a token, to authorise following requests.\n// \t* Use env default credentials, unless overridden by login arguments.\n// \t*/\n// export async function login (user: ICredentialsAPI = { username, password }) {\n//   this.logger.info(`[API] Logging in ${user.username}`)\n//   if (currentLogin !== null) {\n//     this.logger.debug(`[API] Already logged in`)\n//     if (currentLogin.username === user.username) return currentLogin.result\n//     else await logout()\n//   }\n//   const result = (await this.post('login', user, false) as ILoginResultAPI)\n//   if (result && result.data && result.data.authToken) {\n//     currentLogin = {\n//       result: result, // keep to return if login requested again for same user\n//       username: user.username, // keep to compare with following login attempt\n//       authToken: result.data.authToken,\n//       userId: result.data.userId\n//     }\n//     setAuth(currentLogin)\n//     this.logger.info(`[API] Logged in ID ${currentLogin.userId}`)\n//     return result\n//   } else {\n//     throw new Error(`[API] Login failed for ${user.username}`)\n//   }\n// }\n\n// /** Logout a user at end of API calls */\n// export function logout () {\n//   if (currentLogin === null) {\n//     this.logger.debug(`[API] Already logged out`)\n//     return Promise.resolve()\n//   }\n//   this.logger.info(`[API] Logging out ${ currentLogin.username }`)\n//   return this.get('logout', null, true).then(() => {\n//     clearHeaders()\n//     currentLogin = null\n//   })\n// }\n\nexport interface IClient {\n  headers: any\n  get (url: string, data: any, options?: any): Promise<any>\n  post (url: string, data: any, options?: any): Promise<any>\n  put (url: string, data: any, options?: any): Promise<any>\n  delete (url: string, data: any, options?: any): Promise<any>\n}\n\nclass Client implements IClient {\n  host: string\n\n  _headers: any = {}\n\n  constructor ({ host = 'http://localhost:3000' }: any) {\n    this.host = host\n  }\n\n  set headers (obj: any) {\n    this._headers = obj\n  }\n  get headers (): any {\n    return {\n      'Content-Type': 'application/json',\n      ...this._headers\n    }\n  }\n\n  getHeaders (options?: any) {\n    return options && options.customHeaders ?\n      options.customHeaders :\n      this.headers\n  }\n\n  getBody (data: any) {\n    return data instanceof FormData ?\n      data :\n      JSON.stringify(data)\n  }\n\n  get (url: string, data: any, options?: any): Promise<any> {\n    return fetch(`${this.host}/api/v1/${encodeURI(url)}?${this.getParams(data)}`, {\n      method: 'GET',\n      headers: this.getHeaders(options)\n    }).then(this.handle)\n  }\n  post (url: string, data: any, options?: any): Promise<any> {\n    return fetch(`${this.host}/api/v1/${encodeURI(url)}`, {\n      method: 'POST',\n      body: this.getBody(data),\n      headers: this.getHeaders(options)\n    }).then(this.handle)\n  }\n  put (url: string, data: any, options?: any): Promise<any> {\n    return fetch(`${this.host}/api/v1/${encodeURI(url)}`, {\n      method: 'PUT',\n      body: this.getBody(data),\n      headers: this.getHeaders(options)\n    }).then(this.handle)\n  }\n\n  delete (url: string, data?: any, options?: any): Promise<any> {\n    return fetch(`${this.host}/api/v1/${encodeURI(url)}`, {\n      method: 'DELETE',\n      body: this.getBody(data),\n      headers: this.getHeaders(options)\n    }).then(this.handle)\n  }\n  private async handle (r: any) {\n    const { status } = r\n    const data = await r.json()\n\n    return { status, data }\n\n  }\n  private getParams (data: any) {\n    return Object.keys(data).map(function (k) {\n      return encodeURIComponent(k) + '=' + (typeof data[k] === 'object' ? encodeURIComponent(JSON.stringify(data[k])) : encodeURIComponent(data[k]))\n    }).join('&')\n  }\n}\n\nexport const regExpSuccess = /(?!([45][0-9][0-9]))\\d{3}/\n\n/**\n\t* @module API\n\t* Provides a base client for handling requests with generic Rocket.Chat's REST API\n\t*/\n\nexport default class Api extends EventEmitter {\n  userId: string = ''\n  logger: ILogger\n  client: IClient\n  currentLogin: {\n    username: string,\n    userId: string,\n    authToken: string,\n    result: ILoginResultAPI\n  } | null = null\n\n  constructor ({ client, host, logger = Logger }: any) {\n    super()\n    this.client = client || new Client({ host } as any)\n    this.logger = Logger\n  }\n\n  get username () {\n    return this.currentLogin && this.currentLogin.username\n  }\n\n  loggedIn () {\n    return Object.keys(this.currentLogin || {} as any).every((e: any) => e)\n  }\n/**\n\t* Do a request to an API endpoint.\n\t* If it needs a token, login first (with defaults) to set auth headers.\n\t* @param method   Request method GET | POST | PUT | DEL\n\t* @param endpoint The API endpoint (including version) e.g. `chat.update`\n\t* @param data     Payload for POST request to endpoint\n\t* @param auth     Require auth headers for endpoint, default true\n\t* @param ignore   Allows certain matching error messages to not count as errors\n\t*/\n  request = async (\n\t\tmethod: 'POST' | 'GET' | 'PUT' | 'DELETE',\n\t\tendpoint: string,\n\t\tdata: any = {},\n\t\tauth: boolean = true,\n    ignore?: RegExp,\n    options?: any\n\t) => {\n    this.logger && this.logger.debug(`[API] ${ method } ${ endpoint }: ${ JSON.stringify(data) }`)\n    try {\n      if (auth && !this.loggedIn()) {\n        throw new Error('')\n      }\n      let result\n      switch (method) {\n        case 'GET': result = await this.client.get(endpoint, data, options); break\n        case 'PUT': result = await this.client.put(endpoint, data, options); break\n        case 'DELETE': result = await this.client.delete(endpoint, data, options); break\n        default:\n        case 'POST': result = await this.client.post(endpoint, data, options); break\n      }\n      if (!result) throw new Error(`API ${ method } ${ endpoint } result undefined`)\n      if (!this.success(result, ignore)) throw result\n      this.logger && this.logger.debug(`[API] ${method} ${endpoint} result ${result.status}`)\n      const hasDataInsideResult = result && !result.data\n      return (method === 'DELETE') && hasDataInsideResult ? result : result.data\n    } catch (err) {\n      this.logger && this.logger.error(`[API] POST error(${ endpoint }): ${ JSON.stringify(err) }`)\n      throw err\n    }\n  }\n\t/** Do a POST request to an API endpoint. */\n  post: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('POST', endpoint, data, auth, ignore, options)\n\n\t/** Do a GET request to an API endpoint. */\n  get: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('GET', endpoint, data, auth, ignore, options)\n\n\t/** Do a PUT request to an API endpoint. */\n  put: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('PUT', endpoint, data, auth, ignore, options)\n\n\t/** Do a DELETE request to an API endpoint. */\n  del: IAPIRequest = (endpoint, data, auth, ignore, options = {}) => this.request('DELETE', endpoint, data, auth, ignore, options)\n\n\t/** Check result data for success, allowing override to ignore some errors */\n  success (result: any, ignore?: RegExp) {\n    return (\n\t\t\ttypeof result.status === 'undefined' ||\n\t\t\t(result.status && regExpSuccess.test(result.status)) ||\n\t\t\t(result.status && ignore && ignore.test(result.status))\n\t\t) ? true : false\n  }\n\n  async login (credentials: ICredentials, args?: any): Promise<any> {\n    const { data } = await this.post('login', { ...credentials, ...args })\n    this.userId = data.userId\n    this.currentLogin = {\n      username: data.me.username,\n      userId: data.userId,\n      authToken: data.authToken,\n      result: data\n    }\n    this.client.headers = {\n      'X-Auth-Token': data.authToken,\n      'X-User-Id': data.userId\n    }\n    return data\n  }\n  async logout () {\n    if (!this.currentLogin) {\n      return null\n    }\n    const result = await this.post('logout', {}, true)\n    this.userId = ''\n    this.currentLogin = null\n    return result\n  }\n/**\n * Structure message content, optionally addressing to room ID.\n * Accepts message text string or a structured message object.\n */\n  prepareMessage (\n\tcontent: string | IMessage,\n\trid?: string,\n\targs?: any\n): Message {\n    return new Message(content, { rid, roomId: rid, ...args })\n  }\n}\n","/**\n * @module log\n * Basic log handling with ability to override when used within another module.\n */\n\nimport { ILogger } from '../interfaces'\n\n/** Temp logging, should override form adapter's log */\nclass InternalLog implements ILogger {\n  debug (...args: any[]) {\n    // console.log(...args)\n  }\n  info (...args: any[]) {\n    // console.log(...args)\n  }\n  warning (...args: any[]) {\n    // console.warn(...args)\n  }\n  warn (...args: any[]) { // legacy method\n    return this.warning(...args)\n  }\n  error (...args: any[]) {\n    // console.error(...args)\n  }\n}\n\n/** Default basic console logging */\nexport let logger: ILogger = new InternalLog()\n\n/** Substitute logging handler */\nexport function replaceLog (externalLog: ILogger) {\n  logger = externalLog\n}\n\n/** Null all log outputs */\nexport function silence () {\n  replaceLog({\n    debug: () => null,\n    info: () => null,\n    warn: () => null,\n    warning: () => null,\n    error: () => null\n  })\n}\n","/** A function that emits a side effect and does not return anything. */\nexport type Procedure = (...args: any[]) => void\n\n/** Delay invocation of a function until some time after it was last called */\nexport function debounce<F extends Procedure> (\n  func: F,\n  waitMilliseconds = 100,\n  immediate = false\n): F {\n  let timeout: NodeJS.Timer | undefined\n  return function (this: any, ...args: any[]) {\n    const self = this\n    const doLater = function () {\n      timeout = undefined\n      if (!immediate) func.apply(self, args)\n    }\n    const callNow = immediate && timeout === undefined\n    if (timeout) clearTimeout(timeout)\n    timeout = setTimeout(doLater, waitMilliseconds)\n    if (callNow) func.apply(self, args)\n  } as any\n}\n\n/** Convert a http/s protocol address to a websocket URL */\nexport function hostToWS (host: string, ssl = false) {\n  host = host.replace(/^(https?:\\/\\/)?/, '')\n  return `ws${ssl ? 's' : ''}://${host}`\n}\n","/**\n * @module DDPDriver\n * Handles low-level websocket ddp connections and event subscriptions\n */\n\nimport WebSocket from 'universal-websocket-client'\nimport { EventEmitter } from 'tiny-events'\n\nimport { logger as Logger } from '../log'\nimport { ISocket, IDriver } from './index'\n\nEventEmitter.prototype.removeAllListeners = function (event?: string | any): any {\n  if (event) {\n    this._listeners[event] = []\n  } else {\n    this._listeners = {}\n  }\n  return [] as any\n}\n\nimport {\n  ISocketOptions,\n  ISocketMessageHandler,\n  ISubscription,\n  ICredentials,\n  ILoginResult,\n  ICredentialsPass,\n  isLoginPass,\n  ICredentialsOAuth,\n  isLoginOAuth,\n  ICredentialsAuthenticated,\n  isLoginAuthenticated,\n  isLoginResult,\n  ISocketMessageCallback,\n\tICallback,\n\tILogger\n} from '../../interfaces'\n\nimport { hostToWS } from '../util'\nimport { sha256 } from 'js-sha256'\n\n/** Websocket handler class, manages connections and subscriptions by DDP */\nexport class Socket extends EventEmitter {\n  sent = 0\n  host: string\n  lastPing = Date.now()\n  subscriptions: { [id: string]: ISubscription } = {}\n  handlers: ISocketMessageHandler[] = []\n  config: ISocketOptions | any\n  openTimeout?: NodeJS.Timer | number\n  reopenInterval?: NodeJS.Timer\n  pingTimeout?: NodeJS.Timer | number\n  connection?: WebSocket\n  session?: string\n  logger: ILogger\n\n  /** Create a websocket handler */\n  constructor (\n    options?: ISocketOptions | any,\n    public resume: ILoginResult | null = null\n  ) {\n    super()\n    this.logger = options.logger || Logger\n    this.config = {\n      host: options.host || 'http://localhost:3000',\n      useSsl: options.useSsl || false,\n      reopen: options.reopen || 10000,\n      ping: options.timeout || 30000\n    }\n\n    this.host = `${hostToWS(this.config.host, this.config.useSsl)}/websocket`\n\n    this.on('ping', () => {\n      this.send({ msg: 'pong' }).then(this.logger.debug, this.logger.error)\n    })\n\n    this.on('result', (data: any) => this.emit(data.id, { id: data.id, result: data.result, error: data.error }))\n    this.on('ready', (data: any) => this.emit(data.subs[0], data))\n  }\n\n  /**\n   * Open websocket connection, with optional retry interval.\n   * Stores connection, setting up handlers for open/close/message events.\n   * Resumes login if given token.\n   */\n  open = (ms: number = this.config.reopen) => {\n    return new Promise(async (resolve, reject) => {\n      let connection: WebSocket\n      this.lastPing = Date.now()\n      await this.close()\n      if (this.reopenInterval) clearInterval(this.reopenInterval)\n      this.reopenInterval = setInterval(() => {\n        return !this.alive() && this.reopen()\n      }, ms)\n      try {\n        connection = new WebSocket(this.host)\n        connection.onerror = reject\n      } catch (err) {\n        this.logger.error(err)\n        return reject(err)\n      }\n      this.connection = connection\n      this.connection.onmessage = this.onMessage.bind(this)\n      this.connection.onclose = this.onClose.bind(this)\n      this.connection.onopen = this.onOpen.bind(this, resolve)\n    })\n  }\n\n  /** Send handshake message to confirm connection, start pinging. */\n  onOpen = async (callback: Function) => {\n    const connected = await this.send({\n      msg: 'connect',\n      version: '1',\n      support: ['1', 'pre2', 'pre1']\n    })\n    this.session = connected.session\n    this.ping().catch((err) => this.logger.error(`[ddp] Unable to ping server: ${err.message}`))\n    this.emit('open')\n    if (this.resume) await this.login(this.resume)\n    return callback(this.connection)\n  }\n\n  /** Emit close event so it can be used for promise resolve in close() */\n  onClose = (e: any) => {\n    try {\n      this.emit('close', e)\n      if (e.code !== 1000) {\n        return this.reopen()\n      } else {\n        if (this.reopenInterval) clearInterval(this.reopenInterval)\n        this.openTimeout && clearTimeout(this.openTimeout as any)\n        this.pingTimeout && clearTimeout(this.pingTimeout as any)\n        delete this.connection\n      }\n      this.logger.info(`[ddp] Close (${e.code}) ${e.reason}`)\n\n    } catch (error) {\n      this.logger.error(error)\n    }\n  }\n\n  /**\n   * Find and call matching handlers for incoming message data.\n   * Handlers match on collection, id and/or msg attribute in that order.\n   * Any matched handlers are removed once called.\n   * All collection events are emitted with their `msg` as the event name.\n   */\n  onMessage = (e: any) => {\n    this.lastPing = Date.now()\n    void this.ping()\n    const data = (e.data) ? JSON.parse(e.data) : undefined\n    this.logger.debug(data) // 👈  very useful for debugging missing responses\n    if (!data) return this.logger.error(`[ddp] JSON parse error: ${e.message}`)\n    this.logger.debug(`[ddp] messages received: ${e.data}`)\n    if (data.collection) this.emit(data.collection, data)\n    if (data.msg) this.emit(data.msg, data)\n  }\n\n  /** Disconnect the DDP from server and clear all subscriptions. */\n  close = async () => {\n    if (this.connected) {\n      this.unsubscribeAll().catch(e => this.logger.debug(e))\n      await new Promise((resolve) => {\n        if (this.connection) {\n          this.once('close', resolve)\n          this.connection.close(1000, 'disconnect')\n          return\n        }\n      })\n      .catch(this.logger.error)\n    }\n    return Promise.resolve()\n  }\n\n  /** Clear connection and try to connect again. */\n  reopen = async () => {\n    if (this.openTimeout) return\n    await this.close()\n    this.openTimeout = setTimeout(async () => {\n      delete this.openTimeout\n      await this.open()\n        .catch((err) => this.logger.error(`[ddp] Reopen error: ${err.message}`))\n    }, this.config.reopen)\n  }\n\n  /** Check if websocket connected and ready. */\n  get connected () {\n    return !!(\n      this.connection &&\n      this.connection.readyState === 1 &&\n      this.alive()\n    )\n  }\n\n  /** Check if connected and logged in */\n  get loggedIn () {\n    return (this.connected && !!this.resume)\n  }\n\n  /**\n   * Send an object to the server via Socket. Adds handler to collection to\n   * allow awaiting response matching an expected object. Most responses are\n   * identified by their message event name and the ID they were sent with, but\n   * some responses don't return the ID fallback to just matching on event name.\n   * Data often includes an error attribute if something went wrong, but certain\n   * types of calls send back a different `msg` value instead, e.g. `nosub`.\n   * @param obj       Object to be sent\n   * @param msg       The `data.msg` value to wait for in response\n   * @param errorMsg  An alternate `data.msg` value indicating an error response\n   */\n  send = async (obj: any): Promise<any> => {\n    return new Promise((resolve, reject) => {\n      if (!this.connection) throw new Error('[ddp] sending without open connection')\n      const id = obj.id || `ddp-${ this.sent }`\n      this.sent += 1\n      const data = { ...obj, ...(/connect|ping|pong/.test(obj.msg) ? {} : { id }) }\n      const stringdata = JSON.stringify(data)\n      this.logger.debug(`[ddp] sending message: ${stringdata}`)\n      this.connection.send(stringdata)\n\n      this.once('disconnected', reject)\n      const listener = (data.msg === 'ping' && 'pong') || (data.msg === 'connect' && 'connected') || data.id\n      if (!listener) {\n        return resolve()\n      }\n      this.once(listener, (result: any) => {\n        this.off('disconnect', reject)\n        return (result.error ? reject(result.error) : resolve({ ...(/connect|ping|pong/.test(obj.msg) ? {} : { id }) , ...result }))\n      })\n    })\n  }\n\n  /** Send ping, record time, re-open if nothing comes back, repeat */\n  ping = async () => {\n    this.pingTimeout && clearTimeout(this.pingTimeout as any)\n    this.pingTimeout = setTimeout(() => {\n      this.send({ msg: 'ping' })\n        .then(() => {\n          return this.ping()\n        })\n        .catch(() => this.reopen())\n    }, this.config.ping)\n  }\n  /** Check if ping-pong to server is within tolerance of 1 missed ping */\n  alive = () => {\n    if (!this.lastPing) return false\n    return (Date.now() - this.lastPing <= this.config.ping * 2)\n  }\n\n  /**\n   * Calls a method on the server and returns a promise resolved\n   * with the result of the method.\n   * @param method    The name of the method to be called\n   * @param params    An array with the parameters to be sent\n   */\n  call = async (method: string, ...params: any[]) => {\n    const response = await this.send({ msg: 'method', method, params })\n      .catch((err) => {\n        this.logger.error(`[ddp] Call error: ${err.message}`)\n        throw err\n      })\n    return (response.result) ? response.result : response\n  }\n\n  /**\n   * Login to server and resubscribe to all subs, resolve with user information.\n   * @param credentials User credentials (username/password, oauth or token)\n   */\n  login = async (credentials: any) => {\n    const params = this.loginParams(credentials)\n    this.resume = (await this.call('login', params) as ILoginResult)\n    await this.subscribeAll()\n    this.emit('login', this.resume)\n    return this.resume\n  }\n\n  /** Take variety of login credentials object types for accepted params */\n  loginParams = (\n    credentials:\n      ICredentialsPass |\n      ICredentialsOAuth |\n      ICredentialsAuthenticated |\n      ILoginResult |\n      ICredentials\n  ) => {\n    if (\n      isLoginPass(credentials) ||\n      isLoginOAuth(credentials) ||\n      isLoginAuthenticated(credentials)\n    ) {\n      return credentials\n    }\n    if (isLoginResult(credentials)) {\n      const params: ICredentialsAuthenticated = {\n        resume: credentials.token\n      }\n      return params\n    }\n    const params: ICredentialsPass = {\n      user: { username: credentials.username },\n      password: {\n        digest: sha256(credentials.password),\n        algorithm: 'sha-256'\n      }\n    }\n    return params\n  }\n\n  /** Logout the current User from the server via Socket. */\n  logout = () => {\n    this.resume = null\n    return this.unsubscribeAll()\n\t\t\t.then(() => this.call('logout'))\n  }\n\n  /** Register a callback to trigger on message events in subscription */\n  onEvent = (id: string, callback: ISocketMessageCallback) => {\n    this.on(id, callback)\n  }\n\n  /**\n   * Subscribe to a stream on server via socket and returns a promise resolved\n   * with the subscription object when the subscription is ready.\n   * @param name      Stream name to subscribe to\n   * @param params    Params sent to the subscription request\n   */\n  subscribe = (name: string, params: any[], callback ?: ISocketMessageCallback) => {\n    this.logger.info(`[ddp] Subscribe to ${name}, param: ${JSON.stringify(params)}`)\n    return this.send({ msg: 'sub', name, params })\n      .then((result) => {\n        const id = (result.subs) ? result.subs[0] : undefined\n        const unsubscribe = this.unsubscribe.bind(this, id)\n        const onEvent = this.onEvent.bind(this, name)\n        const subscription = { id, name, params, unsubscribe, onEvent }\n        if (callback) subscription.onEvent(callback)\n        this.subscriptions[id] = subscription\n        return subscription\n      })\n      .catch((err) => {\n        this.logger.error(`[ddp] Subscribe error: ${err.message}`)\n        throw err\n      })\n  }\n\n  /** Subscribe to all pre-configured streams (e.g. on login resume) */\n  subscribeAll = () => {\n    const subscriptions = Object.keys(this.subscriptions || {}).map((key) => {\n      const { name, params } = this.subscriptions[key]\n      return this.subscribe(name, params)\n    })\n    return Promise.all(subscriptions)\n  }\n\n  /** Unsubscribe to server stream, resolve with unsubscribe request result */\n  unsubscribe = (id: any) => {\n    if (!this.subscriptions[id]) return Promise.reject(id)\n    delete this.subscriptions[id]\n    return this.send({ msg: 'unsub', id })\n      .then((data: any) => data.result || data.subs)\n      .catch((err) => {\n        if (!err.msg && err.msg !== 'nosub') {\n          this.logger.error(`[ddp] Unsubscribe error: ${err.message}`)\n          throw err\n        }\n      })\n  }\n\n  /** Unsubscribe from all active subscriptions and reset collection */\n  unsubscribeAll = () => {\n    const unsubAll = Object.keys(this.subscriptions).map((id) => {\n      return this.subscriptions[id].unsubscribe()\n    })\n    return Promise.all(unsubAll)\n      .then(() => this.subscriptions = {})\n  }\n}\n\nexport class DDPDriver extends EventEmitter implements ISocket, IDriver {\n  logger: ILogger\n  config: ISocketOptions\n\t/**\n\t * Event Emitter for listening to connection (echoes selection of DDP events)\n\t * @example\n\t *  import { driver } from '@rocket.chat/sdk'\n\t *  driver.connect()\n\t *  driver.events.on('connected', () => console.log('driver connected'))\n\t */\n\t// events = new EventEmitter()\n\n\t/**\n\t * An Websocket instance for interacting with Rocket.Chat.\n\t * Variable not initialised until `connect` called.\n\t */\n  ddp: Socket\n\n\t/**\n\t * Websocket subscriptions, exported for direct polling by adapters\n\t * Variable not initialised until `prepMeteorSubscriptions` called.\n\t * @deprecated Use `ddp.Socket` instance subscriptions instead.\n\t */\n  subscriptions: { [id: string]: ISubscription } = {}\n\n\t/** Save messages subscription to ensure only one created */\n  messages: ISubscription | undefined\n\n\t/** Current user object populated from resolved login */\n  userId: string = ''\n\n\t/** Array of joined room IDs (for reactive queries) */\n  joinedIds: string[] = []\n\n  constructor ({ host = 'localhost:3000', integrationId, config, logger = Logger, ...moreConfigs }: any = {}) {\n    super()\n\n    this.config = {\n      ...config,\n      ...moreConfigs,\n      host: host.replace(/(^\\w+:|^)\\/\\//, ''),\n      timeout: 20000\n\t\t\t// reopen: number\n\t\t\t// ping: number\n\t\t\t// close: number\n\t\t\t// integration: string\n    }\n    this.ddp = new Socket({ ...this.config, logger })\n    this.logger = logger\n  }\n\n\t/**\n\t * Initialise socket instance with given options or defaults.\n\t * Proxies the DDP module socket connection. Resolves with socket when open.\n\t * Accepts callback following error-first-pattern.\n\t * Error returned or promise rejected on timeout.\n\t * @example <caption>Using promise</caption>\n\t *  import { driver } from '@rocket.chat/sdk'\n\t *  driver.connect()\n\t *    .then(() => console.log('connected'))\n\t *    .catch((err) => console.error(err))\n\t */\n  connect = (c: any = {}): Promise<any> => {\n    if (this.connected) {\n      return Promise.resolve(this)\n    }\n    const config: ISocketOptions = { ...this.config, ...c } // override defaults\n\n    return new Promise((resolve, reject) => {\n      this.logger.info('[driver] Connecting', config)\n      this.subscriptions = this.ddp.subscriptions\n      this.ddp.open().catch((err: Error) => {\n        this.logger.error(`[driver] Failed to connect: ${err.message}`)\n        reject(err)\n      })\n\n      this.ddp.on('open', () => this.emit('connected')) // echo ddp event\n\n      let cancelled = false\n      const rejectionTimeout = setTimeout(() => {\n        this.logger.info(`[driver] Timeout (${config.timeout})`)\n        const err = new Error('Socket connection timeout')\n        cancelled = true\n        this.ddp.removeAllListeners('connected')\n        reject(err)\n      }, config.timeout)\n\n\t\t\t// if to avoid condition where timeout happens before listener to 'connected' is added\n\t\t\t// and this listener is not removed (because it was added after the removal)\n      if (!cancelled) {\n        this.once('connected', () => {\n          this.logger.info('[driver] Connected')\n          if (cancelled) return this.ddp.close() // cancel if already rejected\n          clearTimeout(rejectionTimeout)\n          resolve(this as IDriver)\n        })\n      }\n    })\n  }\n\n  get connected (): boolean {\n    return !!this.ddp.connected\n  }\n\n  disconnect = (): Promise<any> => {\n    return this.ddp.close()\n  }\n\n  subscribe = (topic: string, eventname: string, ...args: any[]): Promise<ISubscription> => {\n    this.logger.info(`[DDP driver] Subscribing to ${topic} | ${JSON.stringify(args)}`)\n    return this.ddp.subscribe(topic, [eventname, { 'useCollection': false, 'args': args }])\n  }\n\n  subscribeNotifyAll = (): Promise< any> => {\n    const topic = 'stream-notify-all'\n    return Promise.all([\n      'roles-change',\n      'updateEmojiCustom',\n      'deleteEmojiCustom',\n      'updateAvatar',\n      'public-settings-changed',\n      'permissions-changed'\n    ].map(event => this.subscribe(topic, event, false)))\n  }\n\n  subscribeLoggedNotify = (): Promise<any> => {\n    const topic = 'stream-notify-logged'\n    return Promise.all([\n      'Users:NameChanged',\n      'Users:Deleted',\n      'updateAvatar',\n      'updateEmojiCustom',\n      'deleteEmojiCustom',\n      'roles-change'\n    ].map(event => this.subscribe(topic, event, false)))\n  }\n\n  subscribeNotifyUser = (): Promise<any> => {\n    const topic = 'stream-notify-user'\n    return Promise.all([\n      'message',\n      'otr',\n      'webrtc',\n      'notification',\n      'rooms-changed',\n      'subscriptions-changed',\n      'uiInteraction'\n    ].map(event => this.subscribe(topic, `${this.userId}/${event}`, false)))\n  }\n\n  subscribeRoom = (rid: string, ...args: any[]): Promise<ISubscription[]> => {\n    const topic = 'stream-notify-room'\n    return Promise.all([\n      this.subscribe('stream-room-messages', rid, ...args),\n      this.subscribe(topic, `${rid}/typing`, ...args),\n      this.subscribe(topic, `${rid}/deleteMessage`, ...args)\n    ])\n  }\n\n\t/** Login to Rocket.Chat via DDP */\n  login = async (credentials: ICredentials, args: any): Promise<any> => {\n    if (!this.ddp || !this.ddp.connected) {\n      await this.connect()\n    }\n    this.logger.info(`[DDP driver] Login with ${JSON.stringify(credentials)}`)\n    const login: ILoginResult = await this.ddp.login(credentials)\n    this.userId = login.id\n    return login\n  }\n  logout = async () => {\n    if (this.ddp && this.ddp.connected) {\n      await this.ddp.logout()\n    }\n\n  }\n\t/** Unsubscribe from Meteor stream. Proxy for socket unsubscribe. */\n  unsubscribe = (subscription: ISubscription) => {\n    return this.ddp.unsubscribe(subscription.id)\n  }\n\n\t/** Unsubscribe from all subscriptions. Proxy for socket unsubscribeAll */\n  unsubscribeAll = (): Promise<any> => {\n    return this.ddp.unsubscribeAll()\n  }\n\n  onStreamData = (event: string, cb: ICallback): Promise<any> => {\n    function listener (message: any) {\n      cb((message))\n    }\n    return Promise.resolve(this.ddp.on(event, listener))\n      .then(() => ({\n        stop: () => this.ddp.off(event, listener)\n      }))\n  }\n\n  onMessage = (cb: ICallback): void => {\n    this.ddp.on('stream-room-messages', ({ fields: { args: [message] } }: any) => cb(this.ejsonMessage(message)))\n  }\n\n  onTyping = (cb: ICallback): Promise<any > => {\n    return this.ddp.on('stream-notify-room', ({ fields: { args: [username, isTyping] } }: any) => {\n      cb(username, isTyping)\n    }) as any\n  }\n\n  notifyVisitorTyping = (rid: string, username: string, typing: boolean, token: string) => {\n    return this.ddp.call('stream-notify-room', `${ rid }/typing`, username, typing, { token })\n  }\n\n  ejsonMessage = (message: any) => {\n    if (message.ts) {\n      message.ts = new Date(message.ts.$date)\n    }\n    return message\n  }\n\n  methodCall = (method: string, ...args: any[]): Promise<any> => {\n    return this.ddp.call(method, ...args)\n  }\n}\n","import { IMessage } from '../interfaces'\n\n// Message class declaration implicitly implements interface\n// https://github.com/Microsoft/TypeScript/issues/340\nexport interface Message extends IMessage {}\n\n/**\n * Rocket.Chat message class.\n * Sets integration param to allow tracing source of automated sends.\n * @param content Accepts message text or a preformed message object\n * @todo Potential for SDK usage that isn't bots, bot prop should be optional?\n */\nexport class Message implements IMessage {\n  constructor (content: string | IMessage, { integrationId, ...others }: any) {\n    if (typeof content === 'string') {\n      Object.assign(this, { msg: content }, others)\n    } else {\n      Object.assign(this, content, others)\n    }\n    if (integrationId) {\n      this.bot = { i: integrationId }\n    }\n  }\n}\n","/**\n * @module ApiLivechat\n * Provides a client for making requests with Livechat Rocket.Chat's REST API\n */\n\nimport {\n\tILivechatTokenAPI,\n\tILivechatRoomCredentialAPI,\n\tILivechatRoomSurveyAPI,\n\tINewLivechatGuestAPI,\n\tINewLivechatMessageAPI,\n\tILivechatRoomMessagesAPI,\n\tINewLivechatNavigationAPI,\n\tINewLivechatCustomFieldAPI,\n\tINewLivechatOfflineMessageAPI,\n\tINewLivechatCustomFieldsAPI,\n\tILivechatRoom,\n\tINewLivechatRoomCredentialAPI,\n\tILivechatUploadAPI\n} from '../../interfaces'\n\nimport ApiBase from './api'\n\nexport default class ApiLivechat extends ApiBase {\n  credentials: ILivechatRoomCredentialAPI = {} as any\n  login (guest: INewLivechatGuestAPI | any) { return this.grantVisitor(guest) }\n  async config (params?: ILivechatTokenAPI) { return (await this.get('livechat/config', params, false)).config }\n  async room (params?: INewLivechatRoomCredentialAPI) { return (await this.get('livechat/room', { token: this.credentials.token, ...params }, false)).room }\n  closeChat ({ rid }: ILivechatRoom) { return this.post('livechat/room.close', { rid, token: this.credentials.token }, false) }\n  transferChat ({ rid, department }: ILivechatRoom) { return (this.post('livechat/room.transfer', { rid, token: this.credentials.token, department }, false)) }\n  chatSurvey (survey: ILivechatRoomSurveyAPI) { return (this.post('livechat/room.survey', { rid: survey.rid, token: this.credentials.token, data: survey.data }, false)) }\n  visitor () { return this.get(`livechat/visitor/${this.credentials.token}`) }\n  async grantVisitor (guest: INewLivechatGuestAPI) {\n    const { visitor } = await this.post('livechat/visitor', guest, false)\n    this.credentials = {\n      token: visitor.token\n    }\n    return visitor\n  }\n  async deleteVisitor () { return (await this.del(`livechat/visitor/${this.credentials.token}`)).visitor }\n  async updateVisitorStatus (status: string) { return (await this.post(`livechat/visitor.status`, { token: this.credentials.token, status })).status }\n  async nextAgent (department: string = '') { return (await this.get(`livechat/agent.next/${this.credentials.token}`, { department })).agent }\n  async agent ({ rid }: any) { return (await this.get(`livechat/agent.info/${rid}/${this.credentials.token}`)).agent }\n  async message (id: string, params: ILivechatRoom) { return (await this.get(`livechat/message/${id}`, { token: this.credentials.token, ...params })).message }\n  sendMessage (message: INewLivechatMessageAPI) { return (this.post('livechat/message', { ...message, token: this.credentials.token }, false)) }\n  editMessage (id: string, message: INewLivechatMessageAPI) { return (this.put(`livechat/message/${id}`, message, false)) }\n  deleteMessage (id: string, { rid }: ILivechatRoom) { return (this.del(`livechat/message/${id}`, { rid, token: this.credentials.token }, false)) }\n  async loadMessages (rid: string, params?: ILivechatRoomMessagesAPI) { return (await this.get(`livechat/messages.history/${rid}`, { ...params, token: this.credentials.token }, false)).messages }\n  async sendOfflineMessage (message: INewLivechatOfflineMessageAPI) { return (await this.post('livechat/offline.message', { ...message }, false)).message }\n  sendVisitorNavigation (page: INewLivechatNavigationAPI) { return (this.post('livechat/page.visited', { ...page }, false)) }\n  requestTranscript (email: string, { rid }: ILivechatRoom) { return (this.post('livechat/transcript', { token: this.credentials.token, rid, email }, false)) }\n  videoCall ({ rid }: ILivechatRoom) { return this.get(`livechat/video.call/${this.credentials.token}`, { rid }, false) }\n  sendCustomField (field: INewLivechatCustomFieldAPI) { return this.post('livechat/custom.field', field, false) }\n  sendCustomFields (fields: INewLivechatCustomFieldsAPI) { return this.post('livechat/custom.fields', fields, false) }\n  uploadFile (params: ILivechatUploadAPI) {\n    const formData = new FormData()\n    const headersNeededForUpload = {\n      'x-visitor-token': this.credentials.token\n    }\n    formData.append('file', params.file)\n    return this.post(`livechat/upload/${params.rid}`, formData, false, undefined, { customHeaders: headersNeededForUpload })\n  }\n}\n","/** Loggers need to provide the same set of methods */\nexport interface ILogger {\n  debug: (...args: any[]) => void\n  info: (...args: any[]) => void\n  warning: (...args: any[]) => void\n  warn: (...args: any[]) => void\n  error: (...args: any[]) => void\n}\n\n/**\n * Connection options type\n * @param host        Host URL:PORT, converted to websocket protocol\n * @param useSsl      Use SSL (https/wss) to connect\n * @param timeout     How long to wait (ms) before abandoning connection\n * @param reopen      ms interval before attempting reopens on disconnect\n * @param ping        ms interval between each ping\n * @param close       ms interval to wait for socket close to succeed\n * @param integration Name added to message `bot` attribute to identify SDK use\n */\nexport interface ISocketOptions {\n  host?: string\n  useSsl?: boolean\n  timeout?: number\n  reopen?: number\n  ping?: number\n  close?: number\n  integration?: string\n}\n\n/**\n * DDP Message Handler defines attributes to match on incoming messages and\n * fire a callback. There may be multiple handlers for any given message.\n * @param callback    Function to call when matching message received\n * @param persist     Optionally (true) to continue using handler after matching\n * @param msg         The `data.msg` value to match in message\n * @param id          The `data.id` value to match in message\n * @param collection  The `data.collection` value to match in message\n */\nexport interface ISocketMessageHandler {\n  callback: ISocketMessageCallback\n  persist?: boolean\n  msg?: string\n  id?: string\n  collection?: string\n}\n\n/** Function interface for DDP message handler callback */\nexport interface ISocketMessageCallback {\n  (data: any): void\n}\n\n/**\n * Message respond options\n * @param rooms       Respond to only selected room/s (names or IDs)\n * @param allPublic   Respond on all public channels (ignores rooms if true)\n * @param dm          Respond to messages in DM / private chats\n * @param livechat    Respond to messages in livechat\n * @param edited      Respond to edited messages\n */\nexport interface IRespondOptions {\n  rooms?: string[]\n  allPublic?: boolean\n  dm?: boolean\n  livechat?: boolean\n  edited?: boolean\n}\n\n/** User credentials generic interface */\nexport interface ICredentials {\n  password: string\n  username: string\n  email?: string\n  ldap?: boolean\n  ldapOptions?: object\n}\n\n/** User credentials for password login method */\nexport interface ICredentialsPass {\n  user: { username: string }\n  password: { digest: string, algorithm: string }\n}\n\n/** Password login credential type guard */\nexport function isLoginPass (params: any): params is ICredentialsPass {\n  return (\n    params.user &&\n    params.password &&\n    params.user.username !== undefined &&\n    params.password.digest !== undefined\n  )\n}\n\n/** User credentials for oath login method  */\nexport interface ICredentialsOAuth {\n  oauth: { credentialToken: string, credentialSecret: string }\n}\n\n/** Password login credential type guard */\nexport function isLoginOAuth (params: any): params is ICredentialsOAuth {\n  return (\n    params.oath &&\n    params.credentialToken !== undefined &&\n    params.credentialSecret !== undefined\n  )\n}\n\n/** User credentials for authenticated login method */\nexport interface ICredentialsAuthenticated {\n  resume: string\n}\n\n/** Password login credential type guard */\nexport function isLoginAuthenticated (params: any): params is ICredentialsAuthenticated {\n  return (params.resume !== undefined)\n}\n\n/**\n * Common args for POST, GET, PUT, DELETE requests\n * @param endpoint The API endpoint (including version) e.g. `chat.update`\n * @param data     Payload for POST request to endpoint\n * @param auth     Require auth headers for endpoint, default true\n * @param ignore   Allows certain matching error messages to not count as errors\n */\nexport interface IAPIRequest {\n  (\n    endpoint: string,\n    data?: any,\n    auth?: boolean,\n    ignore?: RegExp,\n    options?: any\n  ): Promise<any>\n}\n\n/**\n * Response from login method (called by websocket)\n * @todo make test to inspect websocket login result interface\n */\nexport interface ILoginResult {\n  id: string, // userId\n  token: string,\n  createCipher: { '$date': number }\n}\n\n/** Password login credential type guard */\nexport function isLoginResult (params: any): params is ILoginResult {\n  return (params.token !== undefined)\n}\n\n/** Credentials for logging into API */\nexport interface ICredentialsAPI {\n  username: string\n  password: string\n}\n\n/**\n * Result object from an API login\n * @param status      e.g. 'success'\n * @param data        Logged in user data\n * @param data.authToken Login renewal token\n * @param userId      ID of logged-in user\n */\nexport interface ILoginResultAPI {\n  status: string // e.g. 'success'\n  data: {\n    authToken: string\n    userId: string\n  }\n}\n\n/** Error-first callback param type */\nexport interface ICallback {\n  (error: Error | null, ...args: any[]): void\n}\n\n/** Error-first callback for message stream events */\nexport interface IMessageCallback {\n  (error: Error | null, message?: IMessage, meta?: IMessageMeta): void\n}\n\n/**\n * Websocket stream subscription\n * @param id          Subscription ID\n * @param name        Stream/collection name\n * @param unsubscribe Method for unsubscribing\n */\nexport interface ISubscription {\n  id?: string\n  name?: any\n  unsubscribe: () => Promise<any>\n  onEvent: (callback: ISocketMessageCallback) => void\n  [key: string]: any\n}\n\n/**\n * Subscription events (changes) in message stream\n * @param msg         The event type (usually 'change')\n * @param collection  Streamed collection name, e.g. 'stream-room-messages'\n * @param id          Collection ID (some streams don't include other than 'id')\n * @param fields      Emitted event arguments\n * @param fields.eventName The room or sub-collection name for this event\n * @param fields.args Event rgs, for message events it will be message and meta\n */\nexport interface ISubscriptionEvent {\n  msg: string\n  collection: 'stream-room-messages'\n  id: 'id'\n  fields: {\n    eventName: '__my_messages__'\n    args: [ IMessage, IMessageMeta ]\n  }\n}\n\n/**\n * API result for channel.history request\n * @todo Incomplete\n */\nexport interface IHistoryAPI {\n  messages: IMessageReceipt[]\n}\n\n/**\n * Message schema\n * @param rid         Room ID\n * @param _id         Mongo collection ID generated by Random.id()\n * @param t           Room type e.g. \"c\" for channel\n * @param msg         Text content\n * @param alias       ?\n * @param emoji       Emoji to use as avatar\n * @param avatar      URL of avatar image\n * @param groupable   Group with consecutive messages\n * @param bot         Integration details\n * @param urls        ?\n * @param mentions    ?\n * @param u           User who sent the message\n * @param ts          Message created timestamp\n * @param editedBy    User who edited the message\n * @param editedAt    When the message was edited\n * @todo contribute these to @types/rocketchat and require\n */\nexport interface IMessage {\n  rid?: string\n  _id?: string\n  t?: string\n  msg?: string\n  alias?: string\n  emoji?: string\n  avatar?: string\n  groupable?: boolean\n  bot?: any\n  urls?: string[]\n  mentions?: string[]\n  attachments?: IMessageAttachment[]\n  reactions?: IMessageReaction\n  location ?: IMessageLocation\n  u?: IUser\n  ts?: { '$date': Date }\n  editedBy?: IUser\n  editedAt?: { '$date': Date }\n}\n\n/**\n * Extra details emitted about message in stream events.\n * @param roomParticipant If the logged in user was joined to the room\n * @param roomType    Type of room (public, private, DM, livechat)\n * @param roomName    The room name if public or named private group\n */\nexport interface IMessageMeta {\n  roomParticipant: boolean\n  roomType: RoomType\n  roomName?: 'general'\n}\n\n/**\n * Message receipt returned after send (not the same as sent object).\n * @todo Confirm why/if this is actually different to IMessage, e.g. msg vs text\n * @param _id         ID of sent message\n * @param rid         Room ID of sent message\n * @param alias       ?\n * @param msg         Content of message\n * @param parseUrls   URL parsing enabled on message hooks\n * @param groupable   Grouping message enabled\n * @param ts          Timestamp of message creation\n * @param _updatedAt  Time message last updated\n * @param editedAt    Time updated by edit\n */\nexport interface IMessageReceipt {\n  _id: string\n  rid: string\n  alias: string\n  msg: string\n  parseUrls: boolean\n  groupable: boolean\n  ts: string\n  _updatedAt: string\n  editedAt?: string\n  u: IUser\n  editedBy?: IUser\n  attachments?: IAttachmentAPI[]\n  reactions?: IMessageReaction\n}\n\n/**\n * Payload structure for `chat.postMessage` endpoint\n * @param roomId      The room id of where the message is to be sent\n * @param channel     The channel name with the prefix in front of it\n * @param text        The text of the message to send is optional because of attachments\n * @param alias       This will cause the messenger name to appear as the given alias but username will still display\n * @param emoji       If provided this will make the avatar on this message be an emoji\n * @param avatar      If provided this will make the avatar use the provided image url\n */\nexport interface IMessageAPI {\n  roomId: string\n  channel?: string\n  text?: string\n  alias?: string\n  emoji?: string\n  avatar?: string\n  attachments?: IAttachmentAPI[]\n}\n\n/**\n * Payload structure for `chat.update` endpoint\n * @param roomId      The room id of where the message is\n * @param msgId       The message id to update\n * @param text        Updated text for the message\n */\nexport interface IMessageUpdateAPI {\n  roomId: string\n  msgId: string\n  text: string\n}\n\n/** Message Attachment schema */\nexport interface IMessageAttachment {\n  fields?: IAttachmentField[]\n  actions?: IMessageAction[]\n  color?: string\n  text?: string\n  ts?: string\n  thumb_url?: string\n  message_link?: string\n  collapsed?: boolean\n  author_name?: string\n  author_link?: string\n  author_icon?: string\n  title?: string\n  title_link?: string\n  title_link_download?: string\n  image_url?: string\n  audio_url?: string\n  video_url?: string\n}\n\n/** Attachment field schema */\nexport interface IAttachmentField {\n  short?: boolean\n  title?: string\n  value?: string\n}\n\n/** Message emoji reaction attribute schema (emoji: [usernames that reacted]) */\nexport interface IMessageReaction {\n  [emoji: string]: { usernames: string[] }\n}\n\n/** Rich message action schema */\nexport interface IMessageAction {\n  type?: string\n  text?: string\n  url?: string\n  image_url?: string\n  is_webview?: boolean\n  webview_height_ratio?: 'compact' | 'tall' | 'full'\n  msg?: string\n  msg_in_chat_window?: boolean\n  button_alignment?: 'vertical' | 'horizontal'\n  temporary_buttons?: boolean\n}\n\n/** Geo-location attribute schema */\nexport interface IMessageLocation {\n  type: string                // e.g. Point\n  coordinates: string[]       // longitude latitude\n}\n\n/**\n * Payload structure for message attachments\n * @param color       The color you want the order on the left side to be any value background-css supports\n * @param text        The text to display for this attachment it is different than the message text\n * @param ts          ISO timestamp displays the time next to the text portion\n * @param thumb_url   An image that displays to the left of the text looks better when this is relatively small\n * @param message_link Only applicable if the ts is provided as it makes the time clickable to this link\n * @param collapsed   Causes the image audio and video sections to be hiding when collapsed is true\n * @param author_name Name of the author\n * @param author_link Providing this makes the author name clickable and points to this link\n * @param author_icon Displays a tiny icon to the left of the author's name\n * @param title       Title to display for this attachment displays under the author\n * @param title_link  Providing this makes the title clickable pointing to this link\n * @param title_link_download_true When this is true a download icon appears and clicking this saves the link to file\n * @param image_url   The image to display will be “big” and easy to see\n * @param audio_url   Audio file to play only supports what html audio does\n * @param video_url   Video file to play only supports what html video does\n */\nexport interface IAttachmentAPI {\n  color?: string\n  text?: string\n  ts?: string\n  thumb_url?: string\n  message_link?: string\n  collapsed?: boolean\n  author_name?: string\n  author_link?: string\n  author_icon?: string\n  title?: string\n  title_link?: string\n  title_link_download_true?: string\n  image_url?: string\n  audio_url?: string\n  video_url?: string\n  fields?: IAttachmentFieldAPI[]\n  actions?: IMessageAction[]\n}\n\n/**\n * Payload structure for attachment field object\n * The field property of the attachments allows for “tables” or “columns” to be displayed on messages\n * @param short       Whether this field should be a short field\n * @param title       The title of this field\n * @param value       The value of this field displayed underneath the title value\n */\nexport interface IAttachmentFieldAPI {\n  short?: boolean\n  title: string\n  value: string\n}\n\n/**\n * Result structure for message endpoints\n * @param ts          Seconds since unix epoch\n * @param channel     Name of channel without prefix\n * @param message     Sent message\n * @param success     Send status\n */\nexport interface IMessageResultAPI {\n  ts: number\n  channel: string\n  message: IMessageReceipt\n  success: boolean\n}\n\n/**\n * User (as attribute) schema\n * @param _id         Mongo collection ID generated by Random.id()\n * @param username    Username\n * @param name        Display name\n */\nexport interface IUser {\n  _id: string\n  username: string\n  name?: string\n}\n\n/**\n * User object structure for creation endpoints\n * @param email       Email address\n * @param name        Full name\n * @param password    User pass\n * @param username    Username\n * @param active      Subscription is active\n * @param roles       Role IDs\n * @param joinDefaultChannels Auto join channels marked as default\n * @param requirePasswordChange Direct to password form on next login\n * @param sendWelcomeEmail  Send new credentials in email\n * @param verified    Email address verification status\n */\nexport interface INewUserAPI {\n  email?: string\n  name?: string\n  password: string\n  username: string\n  active?: true\n  roles?: string[]\n  joinDefaultChannels?: boolean\n  requirePasswordChange?: boolean\n  sendWelcomeEmail?: boolean\n  verified?: true\n}\n\n/**\n * User object structure for queries (not including admin access level)\n * @param _id         MongoDB user doc ID\n * @param type        user / bot ?\n * @param status      online | offline\n * @param active      Subscription is active\n * @param name        Full name\n * @param utcOffset   Hours off UTC/GMT\n * @param username    Username\n */\nexport interface IUserAPI {\n  _id: string\n  type: string\n  status: string\n  active: boolean\n  name: string\n  utcOffset: number\n  username: string\n}\n\n/**\n * Result structure for user data request (by non-admin)\n * @param user    The requested user\n * @param success Status of request\n */\nexport interface IUserResultAPI {\n  user: IUserAPI\n  success: boolean\n}\n\n/** Room type literal (channel private direct livechat) */\nexport type RoomType = 'c' | 'p' | 'd' | 'l'\n\n/**\n * Room object structure from API\n * @param _id         Room ID\n * @param _updatedAt  ISO timestamp\n * @param ts          ISO timestamp (current time in room?)\n * @param msgs        Count of messages in room\n */\nexport interface IRoomAPI {\n  t: RoomType\n  _id: string\n  _updatedAt: string\n  ts: string\n  msgs: number\n  meta: IRoomMetaAPI\n}\n\n/** Room result meta from API */\nexport interface IRoomMetaAPI {\n  revision: number\n  created: number\n  version: number\n}\n\n/**\n * Channel result schema\n * @param _id         Channel ID\n * @param name        Channel name\n * @param default     Is default channel\n * @param ts          ISO timestamp (current time in room?)\n * @param msgs        Count of messages in room\n */\nexport interface IChannelAPI {\n  t: RoomType\n  _id: string\n  name: string\n  default: boolean\n  ts: string\n  msgs: number\n  u: IUser\n}\n\n/**\n * Group (private room) result schema\n * @param _id         Group ID\n * @param name        Group name\n * @param default     Is default channel (would be false)\n * @param usernames   Users in group\n * @param msgs        Count of messages in room\n * @param ts          ISO timestamp (current time in room?)\n */\nexport interface IGroupAPI {\n  t: RoomType\n  _id: string\n  name: string\n  default: boolean\n  usernames: string[]\n  msgs: number\n  ts: string\n  u: IUser\n}\n\n/** Result structure for room creation (e.g. DM) */\nexport interface IRoomResultAPI {\n  room: IRoomAPI\n  success: boolean\n}\n\n/** Result structure for channel creation */\nexport interface IChannelResultAPI {\n  channel: IChannelAPI\n  success: boolean\n}\n\n/** Result structure for group creation */\nexport interface IGroupResultAPI {\n  group: IGroupAPI\n  success: boolean\n}\n\n/** Structure for livechat token field api */\nexport interface ILivechatTokenAPI {\n  token: string\n}\n\n/** Structure for livechat room credential api */\nexport interface ILivechatRoomCredentialAPI {\n  token: string\n}\n/** Structure for livechat room credential api */\nexport interface ILivechatRoom {\n  rid: string\n  department?: string\n}\n\n/** Structure to get(new) livechat room */\nexport interface INewLivechatRoomCredentialAPI {\n  rid?: string\n  agentId?: string\n}\n\n/** Structure for livechat room messages api */\nexport interface ILivechatRoomMessagesAPI {\n  token: string   // Visitor token\n  ts?: string     // ISO timestamp\n  end?: string    // ISO timestamp\n  limit?: number   // number of messages to load\n}\n\n/** Payload structure for livechat `room.transfer` endpoint */\nexport interface ILivechatRoomTransferAPI {\n  token: string\n  department: string\n}\n\n/** Payload structure for livechat survey values */\nexport interface ILivechatSurveyAPI {\n  name: 'satisfaction' | 'agentKnowledge' | 'agentResponsiveness' | 'agentFriendliness'\n  value: '1' | '2' | '3' | '4' | '5'\n}\n\n/** Payload structure for livechat `room.transfer` endpoint */\nexport interface ILivechatRoomSurveyAPI {\n  rid: string\n  data?: ILivechatSurveyAPI[] // See surcvey interface above\n}\n\n/** Livechat New Room object structure */\nexport interface ILivechatNewRoomAPI {\n  _id: string           // Room ID\n  _updatedAt: string    // ISO timestamp\n  t: 'r'                // Room type (channel, private, direct, livechat)\n  msgs: number          // Count of messages in room\n  ts: string            // ISO timestamp (current time in room?)\n  lm?: string           // ISO timestamp (last message)\n  open?: boolean        // Room status\n  departmentId?: string // Livechat Department _id\n  fname: string         // Room display name\n  v: {\n\t  _id: number         // Visitor ID\n\t  token: string       // Visitor token\n\t  username: number    // Visitor username\n  }\n}\n\n/** Result structure for room creation (e.g. DM) */\nexport interface ILivechatNewRoomResultAPI {\n  room: ILivechatNewRoomAPI\n  newRoom: boolean\n  success: boolean\n}\n\n/** Custom Field object structure for livechat endpoints */\nexport interface ILivechatGuestCustomFieldAPI {\n  key: string\n  value: string\n  overwrite: boolean\n}\n\n/** Payload structure for new Livechat Visitors */\nexport interface ILivechatGuestAPI {\n  token: string\n  name?: string\n  email?: string\n  department?: string\n  phone?: string\n  username?: string\n  customFields?: ILivechatGuestCustomFieldAPI[]\n}\n\n/** Visitor object structure for livechat endpoints */\nexport interface INewLivechatGuestAPI {\n  visitor: ILivechatGuestAPI\n}\n\n/** Payload structure for new Livechat Message */\nexport interface INewLivechatMessageAPI {\n  _id?: string          // Message ID\n  msg: string           // Message text\n  token: string         // Livechat Token\n  rid: string           // Room ID\n  agent?: {\n    agentId: string\n    username: string\n  }\n}\n\n/** Result structure for visitor emails */\nexport interface ILivechatEmailAPI {\n  address: string,\n  verified?: boolean\n}\n\n/** Result structure for visitor phones */\nexport interface ILivechatVisitorPhoneAPI {\n  phoneNumber: string\n}\n\n/** Result structure for visitor prop */\nexport interface ILivechatVisitorAPI {\n  token: string\n  _updatedAt: string\n  name?: string\n  phone?: ILivechatVisitorPhoneAPI[]\n  username: string\n  visitorEmails?: ILivechatEmailAPI[]\n  livechatData?: object\n}\n\n/** Result structure for visitor creation */\nexport interface ILivechatVisitorResultAPI {\n  visitor: ILivechatVisitorAPI\n  success: boolean\n}\n\n/** Result structure for config survey */\nexport interface ILivechatConfigSurveyAPI {\n  items: ['satisfaction', 'agentKnowledge', 'agentResponsiveness', 'agentFriendliness']\n  values: ['1', '2', '3', '4', '5']\n}\n\n/** Result structure for config prop */\nexport interface ILivechatConfigAPI {\n  enabled: boolean\n  online?: boolean\n  settings?: object\n  theme?: object\n  messages?: object\n  survey?: ILivechatConfigSurveyAPI,\n  guest?: ILivechatGuestAPI\n}\n\n/** Result structure for Livechat config */\nexport interface ILivechatConfigResultAPI {\n  config: ILivechatConfigAPI\n  success: boolean\n}\n\n/** Livechat Room object structure */\nexport interface ILivechatRoomAPI {\n  _id: string           // Room ID\n  open?: boolean        // Room status\n  departmentId?: string // Livechat Department _id\n  servedBy: {\n\t  _id: number         // Agent ID\n    username: number    // Agent username\n  }\n}\n\n/** Result structure for room */\nexport interface ILivechatRoomResultAPI {\n  room: ILivechatRoomAPI\n  success: boolean\n}\n\n/** Livechat Agent object structure */\nexport interface ILivechatAgentAPI {\n  _id: string           // Agent ID\n  name: string          // Agent name\n  username: string      // Agent username\n  emails: ILivechatEmailAPI[]\n}\n\n/** Result structure for agent */\nexport interface ILivechatAgentResultAPI {\n  agent: ILivechatAgentAPI\n  success: boolean\n}\n\n/** Livechat Message object structure */\nexport interface ILivechatMessageAPI {\n  msg: string\n  u: {\n    _id: string\n    username: string\n    name: string\n  }\n  ts: string\n}\n\n/** Result structure for Livechat Message */\nexport interface ILivechatMessageResultAPI {\n  message: ILivechatMessageAPI\n  success: boolean\n}\n\n/** Payload structure for new Livechat Offline Message */\nexport interface INewLivechatOfflineMessageAPI {\n  name: string          // Message Name\n  email: string         // Message email\n  message: string       // Message text\n}\n\n/** Result structure for Livechat Offline Message */\nexport interface ILivechatOfflineMessageResultAPI {\n  message: string\n  success: boolean\n}\n\n/** Navigation object structure for livechat endpoints */\nexport interface ILivechatNavigation {\n  change: string      // Action (Url or Page Title)\n  title: string       // Page Title\n  location: {\n    href: string\n  }\n  token?: string\n}\n\n/** Payload structure for new Livechat Visitor Navigation */\nexport interface INewLivechatNavigationAPI {\n  token: string         // Livechat Token\n  rid: string           // Room ID\n  pageInfo: ILivechatNavigation\n}\n\n/** Result structure for Livechat Navigation */\nexport interface ILivechatNavigationResultAPI {\n  page?: {\n    msg: string\n    navigation: ILivechatNavigation\n  }\n  success: boolean\n}\n\n/** Result structure for Livechat Transcript */\nexport interface ILivechatTranscriptResultAPI {\n  message: string\n  success: boolean\n}\n\n/** Livechat VideoCall object structure */\nexport interface ILivechatVideoCallAPI {\n  rid: string           // Room ID\n  domain: string        // Video Call provider domain\n  provider: string      // Video Call provider name\n  room: string          // Video Call room\n}\n\n/** Result structure for Livechat VideoCall */\nexport interface ILivechatVideoCallResultAPI {\n  videoCall: ILivechatVideoCallAPI\n  success: boolean\n}\n\n/** Payload structure for new Livechat CustomField */\nexport interface ILivechatCustomFieldAPI {\n  key: string\n  value: string\n  overwrite: boolean\n}\n\n/** Livechat CustomField object structure */\nexport interface INewLivechatCustomFieldAPI {\n  key: string          // CustomField key\n  value: string        // CustomField value\n  overwrite: boolean   // Overwrite CustomField value if exists\n}\n\n/** Result structure for Livechat CustomField */\nexport interface ILivechatCustomFieldResultAPI {\n  field: ILivechatCustomFieldAPI\n  success: boolean\n}\n\n/** Structure for Livechat CustomFields api */\nexport interface INewLivechatCustomFieldsAPI {\n  token: string   // Visitor token\n  customFields: ILivechatCustomFieldAPI[]\n}\n\n/** Result structure for Livechat CustomFields */\nexport interface ILivechatCustomFieldsResultAPI {\n  fields: ILivechatCustomFieldAPI[]\n  success: boolean\n}\n\n/** Structure for Livechat Upload api */\nexport interface ILivechatUploadAPI {\n  rid: string\n  file: File\n}\n"],"sourceRoot":""}